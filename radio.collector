<?php

#RCSWITCH-DATA
#RC: 20   1301 01 01
#    FLAG DATA ID TYPE
#Type:
#Signed number: 10
#Temperature : 11
#Add your own sensor
#
#Type:Signed number
#
session_write_close();
if(strlen($collected) == 12){
	$collect_array = explode(":",$collected);
	if($collect_array[0] == 1){
		$code_collected = $collect_array[1];
		//echo $code_collected;
		
		$data_flag = substr($code_collected,0,2);
		

	//This looks like data
		if($data_flag == 20){

	$type_temp = 01; //@todo change prototype to type 11

	$data_type = substr($collected,-2,2);
			
	
	$data_id = substr($collected,-4,2);	
	//echo $data_id; 
	$data_collected = substr($collected,4,4);

	//echo $data_collected;
	
	switch($data_type){
		case $type_temp:
		$sign = $data_collected[0];
		//echo $sign;
		
		$temp_data = substr($data_collected,1,3);
		$temp_data = $temp_data / 10;
		if(!$sign){$temp_data = -$temp_data;}
		$time_to_pool = 10;

		if(!file_exists("/etc/kana/datas/temp.rrd")){

			$step = $time_to_pool * 60;
			$heartbeat = $step * 2;
			$min = -40;
			$max = 50;
			$xff = 0.5;
			$dst = "GAUGE";
			$name_data = "temp";
			/*
			DS:name:DST:heartbeat:min:max

			heartbeat defines the maximum number of seconds that may pass between two updates of this data source before the value of the data source is assumed to be *UNKNOWN*.
			Here we multiplied it by 2.

			min and max define the expected range values for data supplied by a data source. If min and/or max are specified any value outside the defined range will be regarded as *UNKNOWN*.  Note that min and max always refer to the processed values of the DS. For a traffic-COUNTER type DS this would be the maximum and minimum data-rate expected from the device.

			If you do not know or care about min and max, set them to U for unknown.

			If information on minimal/maximal expected values is available, always set the min and/or max properties. This will help RRDtool in doing a simple sanity check on the data supplied when running update.

			RRA:TYPE:xff:steps:rows

			AVERAGE
			the average of the data points is stored.
			MIN
			the smallest of the data points is stored.
			MAX
			the largest of the data points is stored.
			LAST
			the last data points is used.

			xff: The xfiles factor defines what part of a consolidation interval may be made up from *UNKNOWN* data while the consolidated value is still regarded as known. It is given as the ratio of allowed *UNKNOWN* PDPs to the number of PDPs in the interval. Thus, 

			it ranges from 0 to 1 (exclusive).

			steps: defines how many of these primary data points are used to build a consolidated data point which then goes into the archive.

			rows: defines how many generations of data values are kept in an RRA. Obviously, this has to be greater than zero.


			 */
			//We start 10 minutes earlier
			$time = time() - $step;
			$opts = array(
				"--start",$time,
				"--step",$step,
				"DS:".$name_data.":".$dst.":".$heartbeat.":".$min.":".$max,
				"RRA:AVERAGE:".$xff.":1:2800", //1step to consolidate 
				"RRA:AVERAGE:".$xff.":6:700",  //6step to consolidate
				"RRA:AVERAGE:".$xff.":6:700",  //
				"RRA:AVERAGE:".$xff.":24:775",
				"RRA:AVERAGE:".$xff.":144:1500",
				"RRA:AVERAGE:".$xff.":288:2000",
				"RRA:MIN:".$xff.":1:".$step,
				"RRA:MIN:".$xff.":1:".$step,
				"RRA:MIN:".$xff.":6:700",
				"RRA:MIN:".$xff.":24:775",
				"RRA:MIN:".$xff.":144:1500",
				"RRA:MIN:".$xff.":288:2000",
				"RRA:MAX:".$xff.":6:700",
				"RRA:MAX:".$xff.":24:775",
				"RRA:MAX:".$xff.":144:1500",
				"RRA:MAX:".$xff.":288:2000"
				);
			$out = rrd_create("/etc/kana/datas/temp.rrd",$opts);

		}
		$time = time();
		$time = Functions::timestamp_nearest_minutes($time_to_pool);
		$output_update = shell_exec('rrdtool updatev "/etc/kana/datas/temp.rrd" '.$time.':'.$temp_data." 2>&1");
		
		$output_update_array = explode(":",$output_update);
		$iserror = $output_update_array[0];
		$error = $output_update_array[2];
		$error_array = explode(" ",$error);
		
		if($error_array[1] == "illegal"){
			$actual_temp =  shell_exec('rrdtool lastupdate /etc/kana/datas/temp.rrd');
			$lasttemp_data = explode(":",$actual_temp);
			$error = "Data was already saved at this time:".$lasttemp_data[1]."\n";
		}
		
		if($iserror == "ERROR")
		{
			$log_update = $error."Value ".$temp_data." was not saved at ".date('H:i:s d-m-Y ')." ".$time."\n";

		}
		else
		{
			$log_update = $output_update."Value ".$temp_data." was saved at ".date('H:i:s d-m-Y ')." ".$time."\n";
		}

		$file = "/etc/kana/datas/temp.log";
		$current = file_get_contents($file);
		$current .= $log_update;
		file_put_contents($file,$current);
		echo $log_update;
		break;
	}


}

}
}

else{
	$data =	$_["data"]; //Get data
	$type = $_["type"]; //Get object name

	//We save the data with a timestamp
	$db_fields = array(
		"data" => "text",
		"timestamp" => "int"
		);

	//We generate a table to store datas
	$table = "/etc/kana/datas/".$type.".db";
	//echo $_["data"];

	$data_db = new Entity($type,$db_fields,$table,false);
	$count_data = $data_db->rowCount();
	
	//We don't want to store to much codes so we reset the table every 10 recorded codes
	if($count_data > 10){
		$data_db->drop();
		$data_db = new Entity($type,$db_fields,$table,false);
	}
	$data_db->setData($data);
	$data_db->setTimestamp(time());
	$data_db->save();

//Check if a code has a triggers
	$db_triggers = new Entity("Triggers");
	$trigger = $db_triggers->load([
		"code" => $data,
		"trigger" => "one"
		]);

	$alltrigger = $db_triggers->load([
		"trigger" => "all"
		]);

	//@to refactor

	if($data == $trigger["code"]){
		$db_scenario = new Entity("Scenario");
		$scenario = $db_scenario->load([
			"id_trigger" => $trigger["id"]
			]);

		
		if($scenario){
			$timeout_time = $trigger["timestamp"] + $trigger["timeout"];
			$time = $_["time"];
			echo $timeout_time - $time;
			if($timeout_time < $time){
			$db_triggers->change(array('timestamp'=>$time),array('id'=>$trigger["id"]));
			Functions::launch_background("./action.py '".$scenario["action_tag"]."'");
			}
		}
	}

	if($alltrigger){
		$db_scenario = new Entity("Scenario");
		$scenario = $db_scenario->load([
			"id_trigger" => $alltrigger["id"]
			]);

		if($scenario){
			$timeout_time = $alltrigger["timestamp"] + $alltrigger["timeout"];
			$time = $_["time"];
			echo $timeout_time - $time;
			if($timeout_time < $time){
			$db_triggers->change(array('timestamp'=>$time),array('id'=>$alltrigger["id"]));
			Functions::launch_background("./action.py '".$scenario["action_tag"]."'");
			}
		}
	}




}

?>

